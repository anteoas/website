# Anteo Website Architecture Guide

This document explains how the Anteo static site generator works, making it easier for developers (and LLMs) to understand and modify the codebase.

## Overview

The Anteo website is a multilingual static site generator built with Node.js. It transforms Markdown content into a static website with automatic image optimization and deployment to GitHub Pages.

## Directory Structure

```
anteo-website/
├── config/                 # Configuration files
│   ├── build.config.js    # Build settings (languages, paths)
│   └── site.config.js     # Site metadata and render definitions
├── content/               # All content (Markdown files)
│   ├── no/               # Norwegian content
│   │   ├── articles/     # News articles
│   │   ├── pages/        # Static pages
│   │   ├── people/       # Team members (data only)
│   │   ├── products/     # Product pages
│   │   └── site.json     # Site data and strings
│   └── en/               # English content (same structure)
├── src/                   # Source files
│   ├── assets/           # CSS, JS, images
│   │   ├── css/
│   │   ├── js/
│   │   └── images/
│   └── templates/        # Handlebars templates
│       ├── layouts/      # Base layouts
│       ├── pages/        # Page templates
│       └── partials/     # Reusable components
├── scripts/              # Build scripts
│   ├── build.js          # Main build orchestrator
│   ├── build-site.js     # Site generation logic
│   └── dev-server.js     # Development server
└── dist/                 # Build output (gitignored)
```

## Build Process Flow

### 1. Entry Points
- **Production build**: `npm run build` → `scripts/build.js`
- **Development server**: `npm run dev` → `scripts/dev-server.js`

### 2. Build Pipeline (`scripts/build.js`)
```javascript
1. buildSite() - Generate the site
2. determineBasePath() - Calculate deployment path
3. applyDeploymentConfig() - Update URLs for deployment
4. createDeploymentFiles() - Generate CNAME, etc.
```

### 3. Site Generation (`scripts/build-site.js`)

The build follows a simple three-step process:

#### Step 1: Load All Content
```javascript
const contentStore = loadAllContent(lang);
// Returns: { page: [...], article: [...], product: [...], person: [...] }
```

#### Step 2: Check Render Configuration
```javascript
// site.config.js defines which types generate pages
renders: {
  page: { generateUrl, getTemplate },
  article: { generateUrl, getTemplate, backLink },
  product: { generateUrl, getTemplate, backLink }
  // Note: 'person' is not listed, so no pages generated
}
```

#### Step 3: Render Each Item
For each content type with a render definition:
- Get all items of that type
- Render each using its template
- Pass the entire `contentStore` so templates can query any data

### 4. Content Types

All content uses frontmatter to declare its type:

```yaml
---
type: page        # Required: declares content type
title: "About"    # Type-specific fields
template: about   # Optional: override default template
---
```

Content types:
- **page**: Standalone HTML pages
- **article**: News/blog posts with dates
- **product**: Product descriptions with categories
- **person**: Team member data (no pages generated)

### 5. Templates

Templates receive a data object with:
```javascript
{
  // From frontmatter
  ...frontmatter,
  
  // Processed content
  content: '<html>',
  
  // Site data from site.json
  ...siteData,
  
  // The entire content store for querying
  contentStore: {
    page: [...],
    article: [...],
    product: [...],
    person: [...]
  },
  
  // Utility data
  langPrefix: '',
  currentPath: '/about.html',
  backLink: { url, text }  // If configured
}
```

Templates can query any content:
```handlebars
{{#each (getContent 'person')}}
  {{> team-member this}}
{{/each}}
```

### 6. URL Generation

URLs are generated by render configuration in `site.config.js`:
```javascript
page: {
  generateUrl: (item, langPrefix) => `${langPrefix}/${item.slug}.html`
}
article: {
  generateUrl: (item, langPrefix) => {
    const year = new Date(item.frontmatter.date).getFullYear();
    return `${langPrefix}/news/${year}/${slug}.html`;
  }
}
```

### 7. Image Processing

The `ImageProcessor`:
1. Extracts image URLs from HTML
2. Processes images with query parameters: `?size=300x200&format=webp`
3. Replaces URLs in final HTML

### 8. Deployment

After build completes:
1. Base path is determined (GitHub Pages or custom domain)
2. All URLs in HTML/CSS are updated
3. Deployment files (CNAME) are created

## Key Concepts

### Self-Contained Content
Each Markdown file contains all necessary metadata in frontmatter. No dependency on folder structure for behavior.

### Type-Driven Rendering
Whether content generates a page is determined by `site.config.js`, not by the content itself.

### Query-Based Templates
Templates receive the entire content store and can query any data they need using Handlebars helpers.

### Language Structure
- Default language (Norwegian) has no URL prefix
- Other languages get prefix: `/en/about.html`
- Each language has its own `site.json` with translations

## Common Tasks

### Adding a New Content Type
1. Create content with `type: newtype` in frontmatter
2. Add render definition to `site.config.js`:
```javascript
renders: {
  newtype: {
    generateUrl: (item, langPrefix) => `...`,
    getTemplate: (item) => 'newtype-template'
  }
}
```
3. Create template in `src/templates/pages/newtype-template.html`

### Adding a New Page
1. Create `content/no/pages/newpage.md`:
```yaml
---
type: page
title: "New Page"
---
Content here...
```
2. Page will be generated at `/newpage.html`

### Querying Content in Templates
```handlebars
<!-- Get all articles -->
{{#each (getContent 'article')}}
  <h3>{{this.frontmatter.title}}</h3>
{{/each}}

<!-- Sort by a field -->
{{#each (sortBy (getContent 'person') 'order')}}
  {{this.frontmatter.name}}
{{/each}}

<!-- Filter by a field -->
{{#each (filterBy (getContent 'product') 'category' 'logistics')}}
  {{this.frontmatter.title}}
{{/each}}
```

## Debugging

1. **Build output**: Console shows what's being processed
2. **Template data**: Use `{{log this}}` in templates
3. **Content loading**: Check console for loaded counts
4. **Missing content**: Ensure `type` is specified in frontmatter

---

*This guide reflects the simplified content-type architecture implemented in 2025.*
